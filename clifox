#!/usr/bin/python
#main browser file (url fetcher, GUI wrapper, main window thread)
import sys
reload(sys)
sys.setdefaultencoding('utf-8')
import os,os.path
path=os.path.realpath(__file__).rsplit(os.sep,1)[0]+"/modules"
sys.path.append(path)
import configParser
config=configParser.config
import gc,unidecode
import locale
locale.setlocale(locale.LC_ALL,"")
import inspect
import re,time,curses,curses.ascii,sys,Queue,utils,threading,traceback,string,hashlib,shelve,warnings,urlparse,binascii,urllib
import StringIO as stringio
import contentParser as cp
import guiMain
import mozCom
from guiObjects import *
from utils import log,generate_error_report
profiler=0

if "-debug" in sys.argv:
 utils.log("debugging started, port will open on 7777 when page loads")
# import profile
 profiler=1

def makeCleanFunctionName(s):
 if "." not in s:
  return s
 else:
  parts=s.split(".")
  o=""
  o+=parts[0]
  for p in parts[1:]:
   o+=p[0].upper()+p[1:]
 return o

def log2(*args):
 logfh.write(",".join([str(i) for i in args]))
 logfh.write("\n")
 logfh.flush()

class ActiveWindow(guiMain.gui):
 """Manages the active window (the single set of screens available to the user for one webpage)
similar in concept to a tab in Firefox
"""
 def printStructure(self,x):
  output=""
  for i in x:
   if type(i)!=tuple and i.tagName!="#text":
    output+="<%s>\n" % (i.tagName,)
   elif type(i)!=tuple and i.tagName=="#text":
    output+=i.nodeValue.strip()+"\n"
   else:
    output+="</%s>\n" % (i[1].tagName,)
  return output

 @property
 def f(self):
  return self.getFocusedElement()

 def exit(self,*a,**kw):
  try:
   curses.echo(1)
   self.screen.keypad(0)
   self.screen.nodelay(0)
   curses.nocbreak()
  except Exception,e:
   log("exit:err",e)
  sys.exit()

 quit=exit

 def __init__(self,screen,jsQ=None,jsRoot=None,start_url=""):
  """initialize the main window
jsQ points to the queue where JS generated events are sent
jsRoot points to the root class of js
"""
  log("thread:init:activeWindow")
  self.lastMessage=""
  self.daemon=1
  self.start_url=start_url
  self.codeHist=[]
  self.events=[]
  self.local_vars="numLines,_display,nodes,nodes_flat,screenNum,screenPos,screenPosX,url".split(",")
  self.jsQ=jsQ
  self.js=jsRoot
  self.keys=config.mainWindowKeys
  self.windows=[]
  self.windowVars={}
  self.windex=0
  self.screen = screen
  self.screen.nodelay(1)
  self.screen.keypad(1)
  curses.raw(1)
  curses.noecho()
  self.page=None
  self.initVars()
  self.run()

 def initVars(self):
  self.maxy,self.maxx=self.screen.getmaxyx()
  self.curPos=[0,0]
  self.status=self.maxy-1
  self.entry=self.status-1
  self.searchString=""
  self.maxy=self.entry-1
  self.screenPos=0
  self.screenPosX=0
  self.screenNum=0

 def downloadComplete(self,d):
  self.setStatus('The file "%s" has finished downloading.' % (d.get("filename","unavailable"),))

 def downloadStatus(self,d):
  if "progress" in d:
   p=d['progress']
   perc=(p[0]/p[1] if p[1]!=0 else 0.1)*100
   if str(perc).split(".",1)[0].endswith("0") and str(perc).split(".",1)[-1].startswith("00"):
    self.setStatus("%s, %s percent complete" % (str(perc),d['filename'],))

 def urlSuccess(self,d):
  self.setStatus("loaded,%s" % (d['url'],))
  self.url=d['url']
#  self.timer_q=Queue.Queue()
#  self.timer_events=[]
  if hasattr(self,"dom"):
   del self.dom

 def noNext(self, s):
   if config.beeps=='true':
     curses.beep()
   if config.limitMessages=='true':
     self.setStatus("No more %s" % s)

 def noPrev(self, s):
   if config.beeps=='true':
     curses.beep()
   if config.limitMessages=='true':
     self.updateStatus("No previous %s" % s)

 def onStateChangeAll(self,e):
  self.events.append(e)

 def onStateChange(self,e):
  """Ignore the first onStateChange called on the about:blank document"""
#  old=self.dom.document.ref.id
#  self.dom.document.ref.jsrefresh()
#  if self.dom.document.ref.id!=old:
#   return
  self.events.append(e)
#  self.setStatus("event onStateChange")
#  self.page.linkedBrowser.ref.jsrefresh()
#  self.dom=self.page.linkedBrowser.contentDocument.defaultView
#  self.pageRefreshData()
  self.restoreWindow(self.page)
  if "youtube.com" in self.dom.location.host and "youtube.com/embed/" in self.dom.location.href:
   try:
#    self.dom.wrappedJSObject.yt.player.getPlayerByElement("player").playVideo()
    b=self.dom.wrappedJSObject.document.body
    x=b.appendChild(self.dom.wrappedJSObject.document.createElement("div"))
    x.innerHTML='<a onclick="javascript:yt.player.getPlayerByElement(\'player\').playVideo();">play video</a>'
    x.innerHTML+='<a onclick="javascript:yt.player.getPlayerByElement(\'player\').stopVideo();">stop video</a>'
    self.doPaint(1)
   except:
    pass

 def mutation(self,e):
  self.setStatus("")
  self.setStatus(str(len(e)))

 def tabSelect(self,e):
  """firefox fires eventon tab switch"""
  log("tabSelect")
  if self.page:
   self.page.linkedBrowser.ref.jsrefresh()
  if self.page==e.target:
   return
  self.page=e.target
  self.restoreWindow(self.page)

 def load(self,e):
  """trigger on page loads. currently replaced with the onStateChange event to account for the goBack method's lack of triggering of the load event."""
  return
  self.page.linkedBrowser.ref.jsrefresh()
  if e.target.location.href=="about:blank":
   return
  log("page.linkedBrowser.contentDocument",self.page.linkedBrowser.contentDocument,"e.target",e.target)
  if e.target.defaultView==e.target.defaultView.top and self.page.linkedBrowser.contentDocument==e.target:
   self.events.append(e)
   self.dom=e.target.defaultView
   self.dom.ref.jsrefresh()
   log("setting dom to %s" % (str(self.dom),))
   self.setStatus("page %s loaded" % (self.dom.location.href,))
   self.pageRefreshData()

 def onStatusChange(self,e):
  """print status messages to status bar"""
  time.sleep(0.01)
  m=e.aMessage
  if self.lastMessage!=m:
   self.setStatus(m)
   self.lastMessage=m

 def event(self,e):
  """triggers on any event not covered above"""
  self.setStatus(str(e))

 def pageRefreshData(self):
  """create visual layout of webpage data and place that representation on screen
webpage has been received, processed, turned into a dom construct, and had it's load script method run.
now we display the webpage by scanning the nodes for text, and displaying that text layout to screen.
"""
  if profiler==1:
   try:
    self.setStatus("debugger enabled")
    utils.debugger(locals=locals())
    self.setStatus("debugger disabled")
   except:
    pass
  try:
   pass #utils.open("logs/loadedPageText.txt","wb").write(str(self.dom.document.body.parentNode.innerHTML))
  except Exception,e:
   generate_error_report()
  if self.dom==None:
   self.setStatus("waiting for dom...")
   return
  self.setStatus("painting")
  self.screen.clear()
  a=time.time()
  self.paintScreen()
  b=time.time()
  log("painted, time %s" % (str(b-a),))
  self.setStatus("showing screen")
  self.showScreen(screenNum=0,y=0,force=1)
  self.htmlHttpCommands()

 def htmlHttpCommands(self):
  """might check for refresh or url-change requests here, though those should come through events"""
  return

 def toggleStatusBar(self,*l):
  """toggles status bar, limiting displayed text
toggles status bar (the bottom line of the window) to prevent text from changing the window state.
used, e.g. when reading a webpage as a whole document.
"""
  if not hasattr(self,"statusbar"):
   self.statusbar=1
  self.statusbar=-1*self.statusbar
 
 def nextLink(self,*args):
   x=self.moveToElem(self.findElement("A",direction="forward"))
   log("nextLink,%d,%d,%d" % (self.screenNum,self.screenPos,self.screenPosX,))

 def prevLink(self,*args):
  x=self.moveToElem(self.findElement("A",direction="backward"))
  log("prevLink,%d,%d,%d" % (self.screenNum,self.screenPos,self.screenPosX,))

 def jumpToLine(self,lineNumber):
  self.showScreen(y=self.getLineNumber(lineNumber),screenNum=self.getScreenNumber(lineNumber))

 def moveToElem(self,target):
#  log("target:",target)
  if target==None: return
  if type(target)!=tuple:
   target=self.getElementPosition(target)
  y,x,target=target
  self.showScreen(absoluteY=y,x=x)
  return target

 def wrapToFit(self, text, width=80, indent=None):
  log("wrapToFit:",text,width,indent)
  start,end=0,0
  lines=[]
  textLength=len(text)
  if indent!=None:
   end=width-indent
  else:
   end=width
  while end<textLength:
   if text[end]==' ':
    lines.append(text[start:end])
    start=end+1
    end=start+width
   if end==start:
    lines.append(text[start:start+width])
    start=start+width
    end=start+width
   end-=1
  lines.append(text[start:])
  return lines
 
 def forceCachelessPageRefresh(self):
  """send request to refresh the page and bypass the firefox cache"""
  if hasattr(self,"url"):
   self.dom.location.href=url
  else:
   self.setStatus("No page open.")

 def openLocalFile(self):
  fn=self.gFileBrowser()
  self.dom.location.href=fn

 def navigate(self,c=""):
  go=self.prompt("url: ",self.entry, history=None)
  if go=='': return
  self.dom.location.href=go

 def navigateInNewWindow(self,url=None):
  if url==None:
   url=self.prompt("url (new window):",self.entry, history=self.goHistory)
  self.newWindow(url)

 def goBack(self):
  if not self.page.linkedBrowser.canGoBack:
   return self.setStatus("no page to go back to in this tab")
  return self.page.linkedBrowser.goBack()
#  self.dom.defaultView.history.back()

 def urlError(self,d):
  url=d['url']
  err=d['error']
  fErr=repr(err)
  self.updateStatus("Error occured,%s,%s" % (err,url,))
  if "ssl" in fErr.lower():
   if url.split("//",1)[-1].split("/",1)[0] in self.noverify:
    self.pageQ.put(dict(name="go",url=url,verify=False))
    return
   fErrPlain=fErr.strip("(").strip(")").replace("(",".").replace(")",".").replace("..",".")
   ret=self.gListbox(values=["continue and save","cancel","continue"],title="Ignore SSL Certificate Verification security warning?",status=fErr)
   if "continue" in ret[-1]:
    self.pageQ.put(dict(name="go",url=url,verify=False))
   self.noverify.append(url.split("//",1)[1].split("/",1)[0])
   self.updateStatus("")

 def isInElement(self,e,n=None):
  if e in self.parentNodeNames(self.getFocusedElement()): return 1

 def findNextText(self,mx=-1):
  return self.findElement("#text",direction="forward")

 def findPrevText(self,mx=-1):
  return self.findElement("#text",direction="backward")

 def rl (self, history=None, default=None, echo='true', length=None):
  """
prompt for user input, with bindings to that of the default readline implimentation
history: a list of strings which constitutes the previously entered set of strings egiven to the caller of this function during previous calls
default: the default text, entered as if the user had typed it directly
echo: acts as a mask for passwords (set to ' ' in order to not echo any visible character for passwords)
length: the maximum length for this text entry (element.attr=maxlength is the corresponding html attribute)
"""
  y,startX=self.screen.getyx()
  if history!=None:
   current=theEnd=len(history)
   theEnd-=1
  insertMode='true'
  ret=''  # return complete line buffer
  ptr=0
  x=startX
  self.screen.nodelay(0)
  curses.raw(1)
  if default!=None:
   ret=default
   self.screen.addstr(y, startX, echo*len(ret) if echo!='true' else ret)
  while 1:
   c=self.screen.getch()
#   self.setStatus("KeyPress "+str(c))
   if curses.ascii.isprint(c):
    if ptr==len(ret):
     ret+=chr(c)
     if echo!='true': c=echo
     self.screen.addch(y, x, c)
     if x == self.maxx-1:
      tmp=self.screen.instr(y, startX+1)
      self.screen.clrtoeol()
      self.screen.addstr(y, startX, tmp)
    elif insertMode=='true':
     ret=ret[0:ptr]+chr(c)+ret[ptr:]
     if echo!='true': c=echo
     self.screen.insch(y, x, c)
    else:
     ret=ret[0:ptr]+chr(c)+ret[ptr+1:]
     if echo!='true': c=echo
     self.screen.addch(y, x, c)
    if x < self.maxx-1: x += 1
    if length!=None and ptr==length: break
    ptr+=1
   elif c == 3:  # ^C
    self.setStatus("Input aborted!")
    ret=''
    break
   elif c == 10:  # ^J newline
    ret.rstrip(' ')
    break
   elif c in (1, 262):  # ^A, Home key
    x=startX
    ptr=0
    self.screen.addstr(y, startX, ret)
   elif c in (5, 360):  # ^E, End key
    ptr=len(ret)
    if ptr+startX > self.maxx-1:
     self.screen.addstr(y, startX, ret[-self.maxx+1+startX:])
     self.screen.addch(y, self.maxx-1, ' ')
     x=self.maxx-1
    else:
     x=startX+ptr
   elif c in (2, 260):  # ^B, left arrow
    if x-1 >= startX: 
     x -= 1
     ptr -= 1
    elif ptr>0:
     ptr -= 1
     self.screen.addstr(y, startX, ret[ptr:])
    elif config.beeps=='true':
     curses.beep()
   elif c in (6, 261):  # ^f, right arrow
    if x+1 <= startX+len(ret) and x+1 <= self.maxx-1:
     x+=1
     ptr += 1
    elif ptr < len(ret):
     ptr += 1
     self.screen.clrtoeol()
     self.screen.addstr(y, startX, ret[ptr+1-self.maxx+startX:ptr+1])
    elif config.beeps=='true':
     curses.beep()
   elif c == 259:  # Up arrow
    if not history: #history will return non-zero if it has content
     self.setStatus("No history to move up through.")
     if config.beeps=='true':
      curses.beep()
    elif current>0:
     current-=1
     ret=history[current]
     self.screen.clrtoeol()
     self.screen.addstr(y, startX, ret)
    elif config.beeps=='true':
     curses.beep()
   elif c == 258:  # Down arrow
    if not history:
     self.setStatus("No history to move down through.")
     if config.beeps=='true':
      curses.beep()
     continue
    else:
     current+=1
     if current<=theEnd:
      ret=history[current]
     else:
      ret=''
      current-=1  # Don't want it running away.
      if config.beeps=='true':
       curses.beep()
    self.screen.clrtoeol()
    self.screen.addstr(y, startX, ret)
#   elif c == 18:  # ^R Reverse search for Brandon
   elif c in (8, 263):  # ^H, backSpace
    if x > startX: 
     self.screen.delch(y, x-1)
     ret=ret[0:ptr-1]+ret[ptr:]
     x -= 1
     ptr-=1
   elif c in (4, 330):  # ^D, delete
    self.screen.delch(y, x)
    ret=ret[0:ptr]+ret[ptr+1:]
   elif c == 331:  # insert
    if insertMode=='true':
     insertMode='false'
     self.setStatus("Insert Mode off")
    else:
     insertMode='true'
     self.setStatus("Insert Mode On")
   elif c == 21:  # ^U
    x = startX
    ptr=0
    ret=''
    self.screen.move(y, startX)
    self.screen.clrtoeol()
   elif c == 11:  # ^K
    self.screen.clrtoeol()     
    ret=ret[0:ptr]
    self.screen.addstr(y, startX, ret)
   self.screen.move(y, x)
   self.screen.refresh()   
#   self.setStatus("x="+str(x)+" ptr="+str(ptr))
  self.screen.nodelay(1)
  curses.raw(1)
  curses.noecho()
  if history!=None and ret:
   history.append(ret)
  return ret

 def prompt(self,prompt=":",y=None, history=None,default=None,echo='true'):
  pos=self.screen.getyx()
  if y==None: y=self.status
  self.screen.move(y,0)
  self.screen.clrtoeol()
  self.screen.addstr(y, 0, prompt)
  self.screen.move(y, len(prompt)+1)
  c=""
  c=self.rl(history=history,default=default,echo=echo)
  self.setStatus(prompt+c)
  self.screen.move(y,0)
  self.screen.clrtoeol()
  self.screen.move(pos[0],pos[1])
  self.screen.refresh()
  return c

 def onFocus(self,*args):
  d=self.getFocusedElement()
  if d==None:
   return None
#  log("onFocus:d="+str(d)+",parentNodeNames="+str(self.parentNodeNames(d)))
  if d.nodeName=="A":
   p=d
  elif d.nodeName in ("IFRAME","FRAME"):
   p=d
  elif "A" in self.parentNodeNames(d):
   p=d.parentNode
   while p.nodeName!="A": p=p.parentNode
  else:
   return self.setStatus("")
  if p.href!=None:
   url=p.href
  elif p.src:
   url=p.src
  else:
   url=None
  if url!=None:
   self.setStatus(url)
  else:
   self.setStatus("")

 def addToDownloads(self,url=None):
  return self.setStatus("downloading is not currently available")

 def execute(self):
  d=self.getFocusedElement()
#  log("execute:focus:",str(d),repr(d))
#  d.click()
  if "A" in self.parentNodeNames(d):
   log("execute:linkFound:",d)
   while d.nodeName!="A":
    d=d.parentNode
  if (d.nodeName=="INPUT" and str(d.type).lower() in ("button","reset","submit","image")) or (d.nodeName=="BUTTON"):
#   d.click()
#   if d.form.evt_submit():
   return self.doClick(d)
  if self.formElements.intersection(self.parentNodeNames(d)):
   while d!=None and d.nodeName in self.formElements:
    d=d.parentNode
  if d.nodeName in self.formElements:
   try:
    return self.handleFormInput(d)
   except Exception,e:
    return generate_error_report()
  if d.nodeName=="A" and "#" in d.href and d.href.split("#",1)[0]==d.ownerDocument.location.href.split("#",1)[0]:
   anc=d.href.split("#",1)[-1]
   if anc:
    log("looking for anchor",anc)
    x=self.dom.document.getElementById(anc)
    if x!=None:
     return self.moveToElem(x)
  if d.nodeName=="A":
   url=d.href
   log("execute: "+url)
   return self.doClick(d)
#   self.dom.location.href=url
#   return
  if d.nodeName=="IFRAME" or d.nodeName=="FRAME":
   self.dom.location.href=d.src
   return
  return self.doClick(d)

 def doClick(self,e,method="click"):
  evt=self.dom.document.createEvent("MouseEvents")
  evt.initMouseEvent(method, True, True, self.dom, 0, 0, 0, 0, 0, False, False, False, False, 0, None)
  return 0 if e.dispatchEvent(evt) else 1

 def handleFormInput(self,element):
  log("handleFormInput",element)
  e=element
  baseForm=e.form
#parentNodes(name="form",count=1)
#  self.setStatus("hfi:got base form")
  while e!=None and e.nodeName not in self.formElements:
   e=e.parentNode
  if e.nodeName=="OPTION":
#   self.setStatus("HFI:option found")
   e=self.parentNodes(e,name="select",count=1)
  if e.nodeName=="SELECT":
#   self.setStatus("HFI:select")
   opts=e.options
#getElementsByTagName("option")
   opts=[(i,i.textContent.strip()) for i in opts]
   self.setStatus("gListbox,running")
   ret=self.gListbox(title=e.name,values=opts,default=0)
   e.value=ret[0].value
   log("ret:",ret)
   log("form:",e.value)
  elif e.nodeName=="INPUT" and e.type=="text":
   ret=self.prompt(default=e.value)
#self.gEditbox(default=e.value)
   e.value=ret
  elif e.nodeName=="INPUT" and e.type=="password":
   ret=self.prompt(default=e.value,echo="*")
   e.value=ret
  elif e.nodeName=="TEXTAREA":
   ret=self.gEditbox(default=e.textContent)
   e.innerHTML=ret
  elif e.nodeName=="INPUT" and e.type=="radio":
#   self.setStatus("HFI:radio button")
   opts=[i for i in self.getElementsByTagName(baseForm,"input") if i.type=="radio" and i.name==e.name]
   checked=[i for i in opts if i.checked==1]
   checked=0 if len(checked)==0 else opts.index(checked[0])
   opts=[(i,i.value.strip()) for i in opts]
   ret=self.gListbox(title=e.name,values=opts,default=checked)
   log("radio:ret:",ret)
   if ret!=None:
    ret[0].checked=1
    [setattr(o,"checked",0) for o,p in opts if o!=ret[0]]
  elif e.nodeName=="INPUT" and e.type=="checkbox":
#   self.setStatus("HFI:checkbox")
   ret=self.gCheckbox(title=e.name,values=[e.name],checked=e.checked)
   e.checked=ret
  else:
   ret=self.gEditbox(default=e.value,type=e.type)
   e.value=ret
  self.paintScreen()
  self.showScreen()

 def onPositionChange(self):
  self.onFocus()
#  log(str(("screenNum",self.screenNum,"screenPos",self.screenPos,"screenPosX",self.screenPosX)))

 def nextLine(self,*args):
  self._nextLine()
  self.onPositionChange()

 def nextChar(self,*args):
  self._nextChar()
  self.onPositionChange()

 def prevChar(self,*args):
  self._prevChar()
  self.onPositionChange()

 def prevLine(self,*args):
  self._prevLine()
  self.onPositionChange()

 def _nextChar(self,*args):
  self.screenPosX+=1
#~~
  if self.screenPosX>=self.maxx or self.screenPosX>len(self.screen.instr(self.screenPos,0,self.maxx).strip()):
   self.screenPosX=0
   self.nextLine()
  else:
   self.screen.move(self.screenPos,self.screenPosX)

 def _prevChar(self,*args):
  self.screenPosX-=1
  log("sX="+str(self.screenPosX))
  if self.screenPosX<0:
   if self.screenPos==0:
    self.noPrev("characters")
    self.screenPosX+=1
    return
# or self.screenPosX>len(self.screen.instr(self.screenPos,0,self.maxx).strip()):
   log("sX<0,sX="+str(self.screenPosX))
   self.screenPosX=self.maxx-1
   log("sXNowEquals"+str(self.screenPosX))
   self.prevLine()
   log("sXWithPrevLine,sX="+str(self.screenPosX))
   curLineText=self.screen.instr(self.screenPos,0,self.maxx).strip()
   if self.screenPosX>len(curLineText):
    log("sX@%d,lenOfText@%d" % (self.screenPosX,len(curLineText),))
    self.screenPosX=len(curLineText)
    #remember to move to end of current string, since we're moving toend of current line text
  self.screen.move(self.screenPos,self.screenPosX)

 def _nextLine(self,*args):
  log("_nextLine",self.screenPos,self.screenPosX)
  self.screenPos+=1
  if self.screenPos>self.maxy and self.screenPos*self.screenNum<self.numLines:
   log("end of screen, moving to next screen.")
   self.screenPos=0
   self.nextScreen()
   log("screen,line",self.screenNum,self.screenPos)
  elif self.getScreenAbsolutePosition(y=self.screenPos)>self.numLines:
#self.getFocusedElement(y=self.screenPos-1)._display[-1][0]:
#>=self.numLines:
#self.iterNodes(self.dom.document)[-1]._display[-1][:2]==self.getScreenAbsolutePosition(self.screenNum,self.screenPos):
   log("At or past end of document.\nscreen,line,",self.screenNum,self.screenPos)
   self.screenPos-=1
   self.setStatus("EndOfPage,%d,%d,$url" % (self.screenNum,self.screenPos,))
  else:
   log("moving cursor from %d to %d, on screen %d." % (self.screenPos-1,self.screenPos,self.screenNum,))
   self.screen.move(self.screenPos,self.screenPosX)
  self.screen.refresh()

 def _prevLine(self,*args):
  log("_PrevLine",self.screenNum,self.screenPos,self.screenPosX)
  self.screenPos-=1
  if self.screenPos<0 and self.screenNum>0:
   self.screenPos=self.maxy
   self.prevScreen()
  elif self.screenNum==0 and self.screenPos<=0:
   self.screenPos=0
   self.setStatus("StartOfPage,%d,%d,$url" % (self.screenNum,self.screenPos,))
   self.screen.move(self.screenPos,self.screenPosX)
   self.noPrev('lines')
  elif self.screenPos>=0:
   self.screen.move(self.screenPos,self.screenPosX)

 def nextScreen(self,*args):
  log("_nextScreen",self.screenNum,self.screenPos,self.screenPosX)
  self.screenNum+=1
  if (self.maxy+1)*self.screenNum<self.numLines:
    self.screenPos=0
    self.screenPosX=0
    self.screen.move(self.screenPos,self.screenPosX)
    self.showScreen()
    self.screen.refresh()
    log("nextScreen",self.screenNum,self.screenPos)
  else:
   log("nextScreen At  end of page.",self.screenNum,self.screenPos)
   self.screenNum-=1
   self.noNext('screens')
  self.pagePosition()

 def prevScreen(self,*args):
   if self.screenNum==0:
     log("prevScreen at first screen of page",self.screenNum,self.screenPos)
     self.noPrev('screens')
   else:
     self.screenNum-=1
     self.screenPos=self.maxy
     self.screenPosX=len(self.getLineText().strip())
     self.showScreen()
     self.screen.move(self.screenPos,self.screenPosX)
     self.screen.refresh()
     log("prevScreen",self.screenNum,self.screenPos)

 def topOfScreen(self):
  self.screenPos=0
  self.screenPosX=0
  self.screen.move(self.screenPos,self.screenPosX)

 def bottomOfScreen(self):
  self.screenPosX=0
  if self.maxy*(self.screenNum+1)<self.numLines:
    self.screenPos=self.maxy
    self.screen.move(self.screenPos,0)
  else:
    self.screenPos=self.numLines-self.maxy*self.screenNum-1
    self.screen.move(self.screenPos,0)
  log("BottomOfScreen",self.screenPos,self.screenNum)

 def topOfPage(self):
  if self.screenNum!=0:
    self.screenNum=0
    self.screenPos=0
    self.screenPosX=0
    self.showScreen()
  self.topOfScreen()
  log("topOfPage",self.screenPos,self.screenNum)

 def bottomOfPage(self):
   if self.numLines<self.maxy:
     self.bottomOfScreen()
   else:
     self.screenNum=self.numLines/self.maxy
     self.showScreen()
     self.bottomOfScreen()
     log("bottomOfPage",self.screenPos,self.screenNum)

 def startOfLine(self):
   self.screenPosX=0
   self.screen.move(self.screenPos,self.screenPosX)
   log("startOfLine",self.screenPos,self.screenPosX)

 def endOfLine(self):
  self.screenPosX=len(self.screen.instr(self.screenPos,0,self.maxx).strip())-1
  log("endOfLine","screen pos:",self.screenPos,"screen pos X:",self.screenPosX,"screen num:",self.screenNum)
  self.screen.move(self.screenPos,self.screenPosX)

 def pagePosition(self):
  try:
   self.screen.move(self.entry,0)
   self.screen.clrtoeol()
   if config.pagePosition=='pages':
     self.screen.addstr("Page %s of %s" % (self.screenNum+1,self.numLines/self.maxy+1))
   elif config.pagePosition=='percentage':
     self.screen.addstr("%d%% of %d lines." % (((self.screenNum+1)*self.maxy*100)/self.numLines,self.numLines))
   self.screen.move(self.screenPos,self.screenPosX)
   log("pagePosition",config.pagePosition)
   self.screen.refresh()
  except:
   self.setStatus("Page position error")

 def updateStatus(self,*args,**kw):
  self.setStatus(*args,**kw)

 def setStatus(self,txt,*l):
  if isinstance(txt,list): txt=",".join([str(i).strip() for i in txt])
  if l: txt+=" "+" ".join(l)
  if not isinstance(txt,str): txt=str(txt)
  txt=txt.encode('utf-8')
  log("status:",txt)
  cur=self.screen.getyx()
  self.screen.move(self.status,0)
  self.screen.clrtoeol()
  s=txt[:self.maxx-1]
#  log("statusInfo:",self.status,"sText",s,"pos",cur)
  try:
   self.screen.addstr(self.status,0,s)
  except:
   generate_error_report()
   self.setStatus("error")
  self.screen.move(cur[0],cur[1])
  self.screen.refresh()

 def saveWindow(self):
  if self.page:
   p=self.page
   self.windowVars[p]={}
   d=self.windowVars[p]
   [d.__setitem__(i,getattr(self,i,None)) for i in self.local_vars]

 def restoreWindow(self,w=None):
  self.page=w
  self.page.ref.jsrefresh()
  self.page.linkedBrowser.ref.jsrefresh()
  self.dom=self.page.linkedBrowser.contentDocument.defaultView
  self.dom.ref.jsrefresh()
  try:
   d=self.dom.document
  except:
   self.setStatus("No document object to display")
   return
  force=0
  if w in self.windowVars:
   [setattr(self,k,v) for k,v in self.windowVars[w].items() if k in self.local_vars]
  else:
   self.initVars()
   force=1
  self.doPaint(force)

 def doPaint(self,paint=0):
  a=time.time()
  if paint:
   try:
    self.paintScreen()
   except Exception,e:
    self.setStatus(e)
  else:
   log("painted from cache")
  b=time.time()
  log("painted, time %s." % (str(b-a),))
  self.showScreen(force=1)

 def execCode(self):
  p=self.prompt("code:",history=self.codeHist)
  try:
   if ":"==p[0]:
    a=self.js.ref.eval(p[1:])
   else:
    if "=" in p and not [i for i in p.split("=",1)[0] if i not in string.digits+string.letters+"_."]:
     exec p
     a=eval("str("+p.split("=",1)[0].strip()+")")
    else:
     a=eval(p)
   self.setStatus(str(a).split("\n",1)[0])
  except Exception,e:
   self.setStatus("Exc:"+str(e))
   generate_error_report()

 def newWindow(self,url="about:blank"):
  p=self.js.gBrowser.addTab(url)
  p.url=url
  self.moveWindow(id=self.js.Array.indexOf(self.js.gBrowser.visibleTabs,p))

 def nextWindow(self):
  self.moveWindow(1)

 def prevWindow(self):
  self.moveWindow(-1)

 def moveWindow(self,direction=1,id=None):
#~~
  log("moveWindow")
  self.saveWindow()
  _id=id
  id=self.windex
  tl=self.js.gBrowser.visibleTabs.length-1
  if direction and _id==None:
   if direction>0:
    id=id+1 if id<tl else 0
   if direction<0:
    id=id-1 if id>0 else tl
  if _id!=None:
   id=_id
  self.windex=id
  p=self.js.gBrowser.visibleTabs[id]
  self.js.gBrowser.selectedTab=p
  log("selectedTab set")

 def handleLocalKey(self,k,*args):
  if k in self.keys:
   try:
    exec(self.keys[k])
   except Exception,e:
    fp = stringio.StringIO()
    traceback.print_exc(file=fp)
    message = fp.getvalue()
    del fp
    v=str(e)+"\n"+str(message)
    log("KBDError",v)
#~~
    self.setStatus("KeyboardError:%s" % (e,))

 def handleEvent(self,ev):
#  self.events.append(ev)
  log("mainWindow:event:",str(ev))
  try:
   n=ev['t']
   n=n[0].lower()+n[1:]
   m=getattr(self,n)
   try:
    return m(*ev['a'])
   except Exception,e:
    log("eventError:",e)
    generate_error_report()
  except:
   try:
    return self.event(ev)
   except Exception,e:
    generate_error_report()

 def event(self,e):
  self.events.append(e)
  if e.get("m","")=='w': return
#  self.setStatus("event %s" % (e.get("t","noName"),))

 def key(self,k):
  self.setStatus("key %s invalid." % (str(k),))

 def run(self):
  if not getattr(self,"page",None):
   if getattr(self,"start_url","")!=None:
    self.newWindow(getattr(self,"start_url",config.get("homepage","http://bmcginty.hopto.org/form.html")))
   else:
    self.moveWindow(id=0)
    self.restoreWindow(self.js.gBrowser.visibleTabs[0])
  while 1:
   time.sleep(0.01)
   self.js.ref.recv(0.01)
   c=self.screen.getch()
   if c!=-1:
    if c in self.keys:
     self.handleLocalKey(c)
   try:
    event=self.jsQ.get(block=0)
   except Queue.Empty:
    event=None
   if event!=None:
    self.handleEvent(event)
    continue

def main2():
 global quitFlag
 quitFlag=0
 warnings.simplefilter("ignore")
 j,q=mozCom.initCliFox()
 curses.wrapper(ActiveWindow,jsQ=q,jsRoot=j,start_url=[i for i in sys.argv if ":" in i][0] if [i for i in sys.argv if ":" in i] else None)

if __name__=='__main__':
 main2()
